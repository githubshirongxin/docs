(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{644:function(s,e,a){"use strict";a.r(e);var n=a(59),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"高级类型之索引类型、映射类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级类型之索引类型、映射类型"}},[s._v("#")]),s._v(" 高级类型之索引类型、映射类型")]),s._v(" "),a("p",[s._v("我们从本节开始进入TypeScript学习的进阶阶段，因为我们要大量接触"),a("strong",[s._v("类型编程")]),s._v("了。")]),s._v(" "),a("p",[s._v("本节我们将会学习比较抽象的索引类型，这个高级类型虽然相对要难理解一些，但是配合上类型操作符可以做出很多有趣的事情。")]),s._v(" "),a("h2",{attrs:{id:"索引类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引类型"}},[s._v("#")]),s._v(" 索引类型")]),s._v(" "),a("p",[s._v("我们先看一个场景，现在我们需要一个 pick 函数，这个函数可以从对象上取出指定的属性，是的，就是类似于 "),a("code",[s._v("lodash.pick")]),s._v(" 的方法。")]),s._v(" "),a("p",[s._v("在 JavaScript 中这个函数应该是这样的:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function pick(o, names) {\n  return names.map(n => o[n]);\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("如果我们从一个 "),a("code",[s._v("user")]),s._v(" 对象中取出 id ，那么应该这样:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const user = {\n    username: 'Jessica Lee',\n    id: 460000201904141743,\n    token: '460000201904141743',\n    avatar: 'http://dummyimage.com/200x200',\n    role: 'vip'\n}\nconst res = pick(user, ['id'])\n\nconsole.log(res) // [ '460000201904141743' ]\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("那么好了，我们应该如何在 TypeScript 中实现上述函数？结合我们之前学到的知识，你会怎么做？")]),s._v(" "),a("p",[s._v("如何描述 pick 函数的第一个参数 "),a("code",[s._v("o")]),s._v(" 呢?你可能会想到之前提到过的"),a("code",[s._v("可索引类型")]),s._v("，这个对象的 "),a("code",[s._v("key")]),s._v(" 都是 "),a("code",[s._v("string")]),s._v(" 而对应的值可能是任意类型，那么可以这样表示:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("interface Obj {\n    [key: string]: any\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("而第二个参数 "),a("code",[s._v("names")]),s._v(" 很明显是个字符串数组，这个函数其实很容易就用 "),a("code",[s._v("TypeScript")]),s._v(" 写出来了:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function pick(o: Obj, names: string[]) {\n    return names.map(n => o[n]);\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("这样似乎没什么问题，但是如果你够细心的话，还是会发现我们的类型定义不够严谨：")]),s._v(" "),a("ul",[a("li",[s._v("参数 "),a("code",[s._v("names")]),s._v(" 的成员应该是参数 "),a("code",[s._v("o")]),s._v(" 的属性，因此不应该是 string 这种宽泛的定义，应该更加准确")]),s._v(" "),a("li",[s._v("我们 pick 函数的返回值类型为 "),a("code",[s._v("any[]")]),s._v("，其实可以更加精准，pick 的返回值类型应该是所取的属性值类型的联合类型")])]),s._v(" "),a("p",[s._v("我们应该如何更精准的定义类型呢？")]),s._v(" "),a("p",[s._v("这里我们必须了解两个类型操作符：索引类型查询操作符和索引访问操作符。")]),s._v(" "),a("h2",{attrs:{id:"索引类型查询操作符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引类型查询操作符"}},[s._v("#")]),s._v(" 索引类型查询操作符")]),s._v(" "),a("p",[a("code",[s._v("keyof")]),s._v("，即索引类型查询操作符，我们可以用 keyof 作用于泛型 "),a("code",[s._v("T")]),s._v(" 上来获取泛型 T 上的所有 public 属性名构成联合类型。")]),s._v(" "),a("p",[s._v("举个例子，有一个 Images 类，包含 "),a("code",[s._v("src")]),s._v(" 和 "),a("code",[s._v("alt")]),s._v(" 两个 public 属性，我们用 "),a("code",[s._v("keyof")]),s._v(" 取属性名：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Images {\n    public src: string = 'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png'\n    public alt: string = '谷歌'\n    public width: number = 500\n}\n\ntype propsNames = keyof Images\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("效果如下：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13efd03fd86?w=589&h=172&f=png&s=36557",alt:"2019-06-26-06-17-29"}})]),s._v(" "),a("p",[a("code",[s._v("keyof")]),s._v(" 正是赋予了开发者查询索引类型的能力。")]),s._v(" "),a("h2",{attrs:{id:"索引访问操作符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引访问操作符"}},[s._v("#")]),s._v(" 索引访问操作符")]),s._v(" "),a("p",[s._v("我们可以通过 "),a("code",[s._v("keyof")]),s._v(" 查询索引类型的属性名，那么如何获取属性名对应的属性值类型呢？因为在上面提到的 pick 函数中，我们确实有一个需求时获取属性名对应的属性值类型的需求。")]),s._v(" "),a("p",[s._v("这就需要索引访问符出场了，与 JavaScript 种访问属性值的操作类似，访问类型的操作符也是通过 "),a("code",[s._v("[]")]),s._v(" 来访问的，即 "),a("code",[s._v("T[K]")]),s._v("。")]),s._v(" "),a("p",[s._v("再看上面的例子，我们已经取出属性名 "),a("code",[s._v("propsNames")]),s._v(" ，然后通过类型访问的操作符来获取值的类型。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Images {\n    public src: string = 'https://www.google.com.hk/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png'\n    public alt: string = '谷歌'\n    public width: number = 500\n}\n\ntype propsNames = keyof Images\n\ntype propsType = Images[propsNames]\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("效果如下：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13efd59d908?w=535&h=138&f=png&s=22365",alt:"2019-06-26-06-18-48"}})]),s._v(" "),a("p",[s._v("当我们了解了这两个访问符之后，上面的问题就迎刃而解了。")]),s._v(" "),a("p",[s._v("首先我们需要一个泛型 "),a("code",[s._v("T")]),s._v(" 它来代表传入的参数 "),a("code",[s._v("o")]),s._v(" 的类型，因为我们在编写代码时无法确定参数 "),a("code",[s._v("o")]),s._v(" 的类型到底是什么，所以在这种情况下要获取 "),a("code",[s._v("o")]),s._v(" 的类型必须用面向未来的类型–泛型。")]),s._v(" "),a("p",[s._v("那么传入的第二个参数 "),a("code",[s._v("names")]),s._v(" ，它的特点就是数组的成员必须由参数 "),a("code",[s._v("o")]),s._v(" 的属性名称构成，这个时候我们很容易想到刚学习的操作符"),a("code",[s._v("keyof")]),s._v(", "),a("code",[s._v("keyof T")]),s._v("代表参数o类型的属性名的联合类型，我们的参数names的成员类型"),a("code",[s._v("K")]),s._v("则只需要约束到"),a("code",[s._v("keyof T")]),s._v("即可。")]),s._v(" "),a("p",[s._v("我们的返回值就更简单了，我们通过类型访问符"),a("code",[s._v("T[K]")]),s._v("便可以取得对应属性值的类型，他们的数组"),a("code",[s._v("T[K][]")]),s._v("正是返回值的类型。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function pick<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n    return names.map(n => o[n]);\n}\n\nconst res = pick(user, ['token', 'id', ])\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("我们用索引类型结合类型操作符完成了 TypeScript 版的 pick 函数，它不仅仅有更严谨的类型约束能力，也提供了更强大的代码提示能力：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13efd379db1?w=813&h=339&f=png&s=68681",alt:"2019-06-26-06-41-43"}})]),s._v(" "),a("p",[s._v("因此，学会上述操作，对于写基础的类库和工具十分有用。")]),s._v(" "),a("h2",{attrs:{id:"映射类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#映射类型"}},[s._v("#")]),s._v(" 映射类型")]),s._v(" "),a("p",[s._v("在了解映射类型之前，我们不妨看一个例子.")]),s._v(" "),a("p",[s._v("我们有一个User接口，现在有一个需求是把User接口中的成员全部变成可选的，我们应该怎么做？难道要重新一个个"),a("code",[s._v(":")]),s._v("前面加上"),a("code",[s._v("?")]),s._v(",有没有更便捷的方法？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("interface User {\n    username: string\n    id: number\n    token: string\n    avatar: string\n    role: string\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("这个时候映射类型就派上用场了，映射类型的语法是"),a("code",[s._v("[K in Keys]")]),s._v(":")]),s._v(" "),a("ul",[a("li",[s._v("K：类型变量，依次绑定到每个属性上，对应每个属性名的类型")]),s._v(" "),a("li",[s._v("Keys：字符串字面量构成的联合类型，表示一组属性名（的类型）")])]),s._v(" "),a("p",[s._v("那么我们应该如何操作呢？")]),s._v(" "),a("p",[s._v("首先，我们得找到"),a("code",[s._v("Keys")]),s._v("，即字符串字面量构成的联合类型，这就得使用上一节我们提到的"),a("code",[s._v("keyof")]),s._v("操作符，假设我们传入的类型是泛型"),a("code",[s._v("T")]),s._v("，得到"),a("code",[s._v("keyof T")]),s._v("，即传入类型"),a("code",[s._v("T")]),s._v("的属性名的联合类型。")]),s._v(" "),a("p",[s._v("然后我们需要将"),a("code",[s._v("keyof T")]),s._v("的属性名称一一映射出来"),a("code",[s._v("[K in keyof T]")]),s._v("，如果我们要把所有的属性成员变为可选类型，那么需要"),a("code",[s._v("T[K]")]),s._v("取出相应的属性值，最后我们重新生成一个可选的新类型"),a("code",[s._v("{ [K in keyof T]?: T[K] }")]),s._v("。")]),s._v(" "),a("p",[s._v("用类型别名表示就是：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type partial<T> = { [K in keyof T]?: T[K] }\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("我们坐下测试")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type partialUser = partial<User>\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("果然所有的属性都变成了可选类型：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13efd95cbeb?w=476&h=307&f=png&s=43571",alt:"2019-06-26-09-10-03"}})]),s._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("p",[s._v("索引类型与映射类型相对难理解，笔者在刚开始接触的时候也一时半会无法消化，其实最快最好地把这些内容消化的方式就是实战，后面的实战内容我们也会涉及到相关内容，帮助大家更好地消化。")])])}),[],!1,null,null,null);e.default=t.exports}}]);