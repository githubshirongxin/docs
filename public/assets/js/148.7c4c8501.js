(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{631:function(s,n,e){"use strict";e.r(n);var a=e(59),t=Object(a.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"泛型（generic）的妙用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型（generic）的妙用"}},[s._v("#")]),s._v(" 泛型（generic）的妙用")]),s._v(" "),e("p",[s._v("泛型是 TypeScript 中非常重要的一个概念，因为在之后实际开发中任何时候都离不开泛型的帮助，原因就在于泛型给予开发者创造灵活、可重用代码的能力。")]),s._v(" "),e("h2",{attrs:{id:"初识泛型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初识泛型"}},[s._v("#")]),s._v(" 初识泛型")]),s._v(" "),e("p",[s._v("假设我们用一个函数，它可接受一个 number 参数并返回一个 number 参数。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function returnItem (para: number): number {\n    return para\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("我们按以上的写法貌似是没问题的，那么如果我们要接受一个 string 并返回同样一个 string 呢？逻辑是一样的，但是仅仅是类型发生了变化，难道需要再写一遍？")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function returnItem (para: string): string {\n    return para\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("这明显是重复性的代码，我们应该如何才能避免上述情况呢？")]),s._v(" "),e("p",[s._v("难道我们只能用 any 表示了？")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function returnItem (para: any): any {\n    return para\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("我们现在的情况是，我们在静态编写的时候并不确定传入的参数到底是什么类型，只有当在运行时传入参数后我们才能确定。")]),s._v(" "),e("p",[s._v("那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值。")]),s._v(" "),e("p",[s._v("这个类型变量在 TypeScript 中就叫做「泛型」。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function returnItem<T>(para: T): T {\n    return para\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("我们在函数名称后面声明泛型变量 "),e("code",[s._v("<T>")]),s._v("，它用于捕获开发者传入的参数类型（比如说string），然后我们就可以使用T(也就是string)做参数类型和返回值类型了。")]),s._v(" "),e("h2",{attrs:{id:"多个类型参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多个类型参数"}},[s._v("#")]),s._v(" 多个类型参数")]),s._v(" "),e("p",[s._v("定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 "),e("code",[s._v("T")]),s._v(" 和 泛型 "),e("code",[s._v("U")]),s._v("：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h2",{attrs:{id:"泛型变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型变量"}},[s._v("#")]),s._v(" 泛型变量")]),s._v(" "),e("p",[s._v("我们现在假设有这样的需求，我们的函数接受一个数组，如何把数组的长度打印出来，最后返回这个数组，我们应该如何定义？")]),s._v(" "),e("p",[s._v("我们当然得运用上刚才学的泛型：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function getArrayLength<T>(arg: T): T {\n  console.log(arg.length) // 类型“T”上不存在属性“length”\n  return arg\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[s._v("糟糕，在编写过程中报错了，编译器告诉我们「他们不知道类型T上有没有 length 这个属性」。")]),s._v(" "),e("p",[s._v("所以我们得想办法告诉编译器，这个类型 T 是有 length 属性的，不然在编译器眼里，这个 T 是可以代表任何类型的。")]),s._v(" "),e("p",[s._v("我们已经明确知道要传入的是一个数组了，为什么不这样声明呢: "),e("code",[s._v("Array<T>")]),s._v("？")]),s._v(" "),e("p",[s._v("反正传入的类型不管如何，这起码是数组是可以确定的，在这里泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function getArrayLength<T>(arg: Array<T>) {\n  \n  console.log((arg as Array<any>).length) // ok\n  return arg\n}\n\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("h2",{attrs:{id:"泛型接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型接口"}},[s._v("#")]),s._v(" 泛型接口")]),s._v(" "),e("p",[s._v("泛型也可用于接口声明，以上面的函数为例，如果我们将其转化为接口的形式。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("interface ReturnItemFn<T> {\n    (para: T): T\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("那么当我们想传入一个number作为参数的时候，就可以这样声明函数:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const returnItem: ReturnItemFn<number> = para => para\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("h2",{attrs:{id:"泛型类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型类"}},[s._v("#")]),s._v(" 泛型类")]),s._v(" "),e("p",[s._v("泛型除了可以在函数中使用，还可以在类中使用，它既可以作用于类本身，也可以作用与类的成员函数。")]),s._v(" "),e("p",[s._v("我们假设要写一个"),e("code",[s._v("栈")]),s._v("数据结构，它的简化版是这样的:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Stack {\n    private arr: number[] = []\n\n    public push(item: number) {\n        this.arr.push(item)\n    }\n\n    public pop() {\n        this.arr.pop()\n    }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("p",[s._v("同样的问题，如果只是传入 number 类型就算了，可是需要不同的类型的时候，还得靠泛型的帮助。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Stack<T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n\n    public pop() {\n        this.arr.pop()\n    }\n}\n\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("p",[s._v("泛型类看上去与泛型接口差不多， 泛型类使用 "),e("code",[s._v("<>")]),s._v(" 括起泛型类型，跟在类名后面。")]),s._v(" "),e("h2",{attrs:{id:"泛型约束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型约束"}},[s._v("#")]),s._v(" 泛型约束")]),s._v(" "),e("p",[s._v("现在有一个问题，我们的泛型现在似乎可以是任何类型，但是我们明明知道我们的传入的泛型属于哪一类，比如属于 number 或者 string 其中之一，那么应该如何约束泛型呢？")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Stack<T> {\n    private arr: T[] = []\n\n    public push(item: T) {\n        this.arr.push(item)\n    }\n\n    public pop() {\n        this.arr.pop()\n    }\n}\n\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("p",[s._v("我们可以用 "),e("code",[s._v("<T extends xx>")]),s._v(" 的方式约束泛型，比如下图显示我们约束泛型为 number 或者 string 之一，当传入 boolean 类型的时候，就会报错。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/21/16ded4ce42f572c9?w=615&h=411&f=png&s=55443",alt:"2019-06-25-14-41-19"}})]),s._v(" "),e("h2",{attrs:{id:"泛型约束与索引类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型约束与索引类型"}},[s._v("#")]),s._v(" 泛型约束与索引类型")]),s._v(" "),e("p",[s._v("我们先看一个常见的需求，我们要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值，比如：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function getValue(obj: object, key: string) {\n  return obj[key] // error\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("我们会得到一段报错，这是新手 TypeScript 开发者常常犯的错误，编译器告诉我们，参数 "),e("code",[s._v("obj")]),s._v(" 实际上是 "),e("code",[s._v("{}")]),s._v(",因此后面的 "),e("code",[s._v("key")]),s._v(" 是无法在上面取到任何值的。")]),s._v(" "),e("p",[s._v("因为我们给参数 "),e("code",[s._v("obj")]),s._v(" 定义的类型就是 "),e("code",[s._v("object")]),s._v("，在默认情况下它只能是 "),e("code",[s._v("{}")]),s._v("，但是我们接受的对象是各种各样的，我们需要一个泛型来表示传入的对象类型，比如 "),e("code",[s._v("T extends object")]),s._v(":")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function getValue<T extends object>(obj: T, key: string) {\n  return obj[key] // error\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("这依然解决不了问题，因为我们第二个参数 "),e("code",[s._v("key")]),s._v(" 是不是存在于 "),e("code",[s._v("obj")]),s._v(" 上是无法确定的，因此我们需要对这个 "),e("code",[s._v("key")]),s._v(" 也进行约束，我们把它约束为只存在于 "),e("code",[s._v("obj")]),s._v(" 属性的类型，这个时候需要借助到后面我们会进行学习的索引类型进行实现 "),e("code",[s._v("<U extends keyof T>")]),s._v("，我们用索引类型 "),e("code",[s._v("keyof T")]),s._v(" 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，这样一来函数就被完整定义了：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function getValue<T extends object, U extends keyof T>(obj: T, key: U) {\n  return obj[key] // ok\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("比如我们传入以下对象：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const a = {\n  name: 'xiaomuzhu',\n  id: 1\n}\n\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("这个时候 "),e("code",[s._v("getValue")]),s._v(" 第二个参数 "),e("code",[s._v("key")]),s._v(" 的类型被约束为一个联合类型 "),e("code",[s._v("name | id")]),s._v(",他只可能是这两个之一，因此你甚至能获得良好的类型提示：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/21/16ded4ce432593b0?w=606&h=205&f=png&s=25136",alt:"2019-10-18-14-52-35"}})]),s._v(" "),e("h2",{attrs:{id:"使用多重类型进行泛型约束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用多重类型进行泛型约束"}},[s._v("#")]),s._v(" 使用多重类型进行泛型约束")]),s._v(" "),e("p",[s._v("我们刚才学习了通过单一类型对泛型进行约束的方式，那么我们再设想以下场景，如果我们的泛型需要被约束，它只被允许实现以下两个接口的类型呢？")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("interface FirstInterface {\n  doSomething(): number\n}\n\ninterface SecondInterface {\n  doSomethingElse(): string\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("p",[s._v("我们或许会在一个类中这样使用：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Demo<T extends FirstInterface, SecondInterface> {\n  private genericProperty: T\n\n  useT() {\n    this.genericProperty.doSomething()\n    this.genericProperty.doSomethingElse() // 类型“T”上不存在属性“doSomethingElse”\n  }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("p",[s._v("但是只有 "),e("code",[s._v("FirstInterface")]),s._v(" 约束了泛型 "),e("code",[s._v("T")]),s._v("，"),e("code",[s._v("SecondInterface")]),s._v(" 并没有生效，上面的方法并不能用两个接口同时约束泛型，那么我们这样使用呢：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Demo<T extends FirstInterface, T extends SecondInterface> { // 标识符“T”重复\n  ...\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("上述的语法就是错误的，那么应该如何用多重类型约束泛型呢?")]),s._v(" "),e("p",[s._v("实际上我们并不能在定义泛型约束的时候指定多个约束类型，但是我们依然可以通过其他方法来达到我们多类型约束的目的。")]),s._v(" "),e("p",[s._v("比如我们就可以将接口 "),e("code",[s._v("FirstInterface")]),s._v(" 与 "),e("code",[s._v("SecondInterface")]),s._v(" 作为超接口来解决问题：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("interface ChildInterface extends FirstInterface, SecondInterface {\n\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("这个时候 "),e("code",[s._v("ChildInterface")]),s._v(" 是 "),e("code",[s._v("FirstInterface")]),s._v(" 与 "),e("code",[s._v("SecondInterface")]),s._v(" 的子接口，然后我们通过泛型约束就可以达到多类型约束的目的。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("class Demo<T extends ChildInterface> {\n  private genericProperty: T\n\n  useT() {\n    this.genericProperty.doSomething()\n    this.genericProperty.doSomethingElse()\n  }\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("p",[s._v("以上就是我们在多个类型约束泛型中的使用技巧。")]),s._v(" "),e("h2",{attrs:{id:"泛型与-new"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型与-new"}},[s._v("#")]),s._v(" 泛型与 new")]),s._v(" "),e("p",[s._v("我们假设需要声明一个泛型拥有构造函数，比如：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function factory<T>(type: T): T {\n  return new type() // This expression is not constructable.\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("编译器会告诉我们这个表达式不能构造，因为我们没有声明这个泛型 "),e("code",[s._v("T")]),s._v(" 是构造函数，这个时候就需要 "),e("code",[s._v("new")]),s._v(" 的帮助了。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("function factory<T>(type: {new(): T}): T {\n  return new type() // ok\n}\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("参数 "),e("code",[s._v("type")]),s._v(" 的类型 "),e("code",[s._v("{new(): T}")]),s._v(" 就表示此泛型 T 是可被构造的，在被实例化后的类型是泛型 T。")]),s._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),e("p",[s._v("设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：")]),s._v(" "),e("ul",[e("li",[s._v("接口")]),s._v(" "),e("li",[s._v("类的实例成员")]),s._v(" "),e("li",[s._v("类的方法")]),s._v(" "),e("li",[s._v("函数参数")]),s._v(" "),e("li",[s._v("函数返回值")])]),s._v(" "),e("p",[s._v("除了本节介绍的泛型用法之外，还有一些更高级的用法，后面我们会讲到，泛型十分重要，值得我们多进行代码联系来巩固知识。")])])}),[],!1,null,null,null);n.default=t.exports}}]);