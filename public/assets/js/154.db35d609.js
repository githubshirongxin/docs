(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{637:function(s,n,a){"use strict";a.r(n);var e=a(59),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"高级装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级装饰器"}},[s._v("#")]),s._v(" 高级装饰器")]),s._v(" "),a("p",[s._v("我们上一节了解到了最常用的四种装饰器: 类装饰器、属性装饰器、方法装饰器、访问符装饰器，这已经可以满足我们日常开发的需求了。")]),s._v(" "),a("p",[s._v("但是依然有一些比较高级的用法，这些用法虽然在日常开发中并不多见，但是被大量运用在了基础库层面，要想成为一个名高阶的 TypeScript 开发者还是需要更进一步学习。")]),s._v(" "),a("h2",{attrs:{id:"参数装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数装饰器"}},[s._v("#")]),s._v(" 参数装饰器")]),s._v(" "),a("p",[s._v("参数装饰器，顾名思义是用于修饰参数的装饰器，在 Angular 或者 Nestjs 中都有运用，当然很多基础库也用到了参数装饰器。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function logParameter(target: Object, propertyKey: string, index: number) {\n    console.log(target, propertyKey, index);\n}\n\nclass Person {\n    greet(@logParameter message: string,@logParameter name: string): string {\n        return `${message} ${name}`;\n    }\n}\nconst p = new Person();\np.greet('hello', 'xiaomuzhu');\n\n// Person { greet: [Function] } greet 1\n// Person { greet: [Function] } greet 0\n\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("我们看到参数装饰器需要三个参数 "),a("code",[s._v("target")]),s._v("、"),a("code",[s._v("propertyKey")]),s._v("、"),a("code",[s._v("index")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("target —— 当前对象的原型，也就是说，假设 "),a("code",[s._v("Person")]),s._v(" 是当前对象，那么当前对象 "),a("code",[s._v("target")]),s._v(" 的原型就是 "),a("code",[s._v("Person.prototype")])]),s._v(" "),a("li",[s._v("propertyKey —— 参数的名称，上例中指的就是 greet")]),s._v(" "),a("li",[s._v("index —— 参数数组中的位置，比如上例中参数 name 的位置是 1, message 的位置为 0")])]),s._v(" "),a("p",[s._v("参数装饰器其实有他的特殊之处，我们之前学到的装饰器是可以修改被修饰者的行为的，比如我们可以把一个方法的「可写性」禁用了，这就实现了类方法的「只读」效果，但是参数装饰器不可以，他没有"),a("code",[s._v("descriptor")]),s._v("参数，因此没有相关的 API 供它修改被修饰者的行为。")]),s._v(" "),a("p",[s._v("那么，这个参数装饰器还有啥用？")]),s._v(" "),a("p",[s._v("参数装饰器可以提供信息，给比如给类原型添加了一个新的属性，属性中包含一系列信息，这些信息就被成为「元数据」，然后我们就可以使用另外一个装饰器来读取「元数据」。")]),s._v(" "),a("p",[s._v("是的，这像极了Java中的注解。")]),s._v(" "),a("p",[s._v("当然我们那种直接修改类原型属性的方法并不优雅，后面我们会介绍有一种更通用更优雅的方式–元数据反射。")]),s._v(" "),a("h2",{attrs:{id:"装饰器工厂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰器工厂"}},[s._v("#")]),s._v(" 装饰器工厂")]),s._v(" "),a("p",[s._v("我们先假设这样一个场景，比如我们需要几个装饰器，分别把一个类中的部分属性、类本身、方法、参数的名称打印出来，我们应该怎么做?")]),s._v(" "),a("p",[s._v("大家可能会写出四个不同的装饰器来分别装饰到不同成员上:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("@logClass\nclass Person { \n\n  @logProperty\n  public name: string;\n\n  constructor(name : string) { \n    this.name = name;\n  }\n\n  @logMethod\n  public greet(@logParameter message : string) : string { \n    return `${this.name} say: ${message}`;\n  }\n}\n\n// 打印构造函数\nfunction logClass(target: typeof Person) {\n    console.log(target)\n}\n\n// 打印属性名\nfunction logProperty(target: any, propertyKey: string) {\n    console.log(propertyKey);   \n}\n\n// 打印方法名\nfunction logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(propertyKey);   \n}\n\n// 打印参数位置\nfunction logParameter(target: Object, propertyKey: string, index: number) {\n    console.log(index);\n}\n\n// name\n// 0\n// greet\n// [Function: Person]\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br")])]),a("p",[s._v("确实我们达到效果了，但是装饰器通常是用于抽象和重用，如果一个项目或者库有过量装饰器不仅不能达到上述效果，然而会让项目难以维护.")]),s._v(" "),a("p",[s._v("而且上述装饰器其实是有共同点的，他们都是打印一些关键信息，因此我们可以用一个"),a("strong",[s._v("装饰器工厂")]),s._v("来进一步抽象上述代码。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function log(...args : any[]) {\n  switch(args.length) {\n    case 1:\n      return logClass.apply(this, args);\n    case 2:\n      return logProperty.apply(this, args);\n    case 3:\n      if(typeof args[2] === "number") {\n        return logParameter.apply(this, args);\n      }\n      return logMethod.apply(this, args);\n    default:\n      throw new Error("Decorators are not valid here!");\n  }\n}\n\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("p",[s._v("我们之后直接用 "),a("code",[s._v("log")]),s._v(" 代替 "),a("code",[s._v("logClass")]),s._v("、"),a("code",[s._v("logProperty")]),s._v("、"),a("code",[s._v("logMethod")]),s._v("、"),a("code",[s._v("logParameter")]),s._v(" 即可.")]),s._v(" "),a("blockquote",[a("p",[s._v("装饰器工厂就是一个简单的函数，它返回一种类型的装饰器。")])]),s._v(" "),a("h2",{attrs:{id:"装饰器顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#装饰器顺序"}},[s._v("#")]),s._v(" 装饰器顺序")]),s._v(" "),a("p",[s._v("多个装饰器可以同时应用到一个声明上，就像下面的示例：")]),s._v(" "),a("ul",[a("li",[s._v("书写在同一行上：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("@f @g x\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("书写在多行上：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("@f\n@g\nx\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("在 TypeScript 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：")]),s._v(" "),a("ol",[a("li",[s._v("由上至下依次对装饰器表达式求值。")]),s._v(" "),a("li",[s._v("求值的结果会被当作函数，由下至上依次调用。")])]),s._v(" "),a("p",[s._v("如果我们使用装饰器工厂的话，可以通过下面的例子来观察它们求值的顺序：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function f() {\n    console.log("f(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("f(): called");\n    }\n}\n\nfunction g() {\n    console.log("g(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("g(): called");\n    }\n}\n\nclass C {\n    @f()\n    @g()\n    method() {}\n}\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("p",[s._v("在控制台里会打印出如下结果：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("f(): evaluated\ng(): evaluated\ng(): called\nf(): called\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("类中不同声明上的装饰器将按以下规定的顺序应用：")]),s._v(" "),a("ul",[a("li",[s._v("参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。")]),s._v(" "),a("li",[s._v("参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。")]),s._v(" "),a("li",[s._v("参数装饰器应用到构造函数。")]),s._v(" "),a("li",[s._v("类装饰器应用到类。")])]),s._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("p",[s._v("虽然装饰器目前依然在 TC39 的草案阶段，但是其实他已经借助 Babel 或者 TypeScript 广泛运用于各种业务开发或者基础库中，这就得益于它强大的抽象与重用特性，比如 Angular 中就大量运用了装饰器，但是仅仅借助装饰器的力量是不够的，我们知道在Java中有与装饰器非常像的一种语法叫注解，这就不得不提Reflect Metadata了。")])])}),[],!1,null,null,null);n.default=t.exports}}]);