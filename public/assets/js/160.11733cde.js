(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{643:function(s,n,a){"use strict";a.r(n);var t=a(59),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"typescript与react实战-redux篇"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript与react实战-redux篇"}},[s._v("#")]),s._v(" TypeScript与React实战(Redux篇)")]),s._v(" "),a("p",[s._v("我们在真正的项目中不可能仅仅只用组件就可以完成开发工作，一定会涉及到状态管理工具，目前最主流的莫过于 redux，我们会结合 redux 继续开发我们的 todo 应用。")]),s._v(" "),a("h2",{attrs:{id:"定义models"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义models"}},[s._v("#")]),s._v(" \b\b定义Models")]),s._v(" "),a("p",[s._v("很多时候前端没有定义 Model 的习惯，不过在前端越来越重的今天，尤其是 TypeScript 的存在使得 model 定义更加友好。")]),s._v(" "),a("p",[s._v("我们因为只是个 demo，所以数据模型很简单，用简单的接口即可定义:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// models/Todo.ts\nexport interface Todo {\n  id: number\n  name: string\n  done: boolean\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h2",{attrs:{id:"action相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action相关"}},[s._v("#")]),s._v(" \b\bAction相关")]),s._v(" "),a("p",[s._v("我们开始正式编写redux代码，首先需要定义 "),a("code",[s._v("constants")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// constants/todo.ts\nexport enum ActionTodoConstants {\n    ADD_TODO = 'todo/add',\n    TOGGLE_TODO = 'todo/toggle'\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("我们先实现一个 "),a("code",[s._v("addTodo")]),s._v(" 函数:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// actions/todo.ts\nlet id = 0\n\nconst addTodo = (name: string) => ({\n    payload: {\n        todo: {\n            done: false,\n            id: id++,\n            name,\n          }\n    },\n    type: ActionTodoConstants.ADD_TODO,\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("由于在后面的 reducer 中我们需要函数返回的 Action 类型，所以我们得取得每个 action 函数的返回类型，其实这里有一个技巧，就是利用 TypeScript 强大的类型推导来反推出类型，我们可以先定义函数，再推导出类型。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type AddTodoAction = ReturnType<typeof addTodo>\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13cfda1c8da?w=463&h=304&f=png&s=34894",alt:"2019-07-05-18-07-51"}})]),s._v(" "),a("p",[s._v("接下来我们按照同样的方法实现 "),a("code",[s._v("toggleTodo")]),s._v(" 即可")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("export type AddTodoAction = ReturnType<typeof addTodo>\nexport type ToggleTodoAction = ReturnType<typeof toggleTodo>\n\nexport type Action = AddTodoAction | ToggleTodoAction\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h2",{attrs:{id:"reducer相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reducer相关"}},[s._v("#")]),s._v(" Reducer相关")]),s._v(" "),a("p",[s._v("Reducer 部分相对更简单一些，\b我们只需要给对应的参数或者初始 state 加上类型就好了。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// reducers/todo.ts\n\n// 定义State的接口\nexport interface State {\n    todos: Todo[]\n}\n\nexport const initialState: State = {\n    todos: []\n}\n\n// 把之前定义的Action给action参数声明\nexport function reducer(state: State = initialState, action: Action) {\n    switch (action.type) {\n\n      case ActionTodoConstants.ADD_TODO: {\n\n        const todo = action.payload\n\n        return {\n          ...state,\n          todos: [...state.todos, todo]\n        }\n      }\n\n      case ActionTodoConstants.TOGGLE_TODO: {\n\n        const { id } = action.payload\n        return {\n          ...state,\n          todos: state.todos.map(todo => todo.id === id ? { ...todo, done: !todo.done } : todo)\n        }\n      }\n\n      default:\n        return state\n    }\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br")])]),a("p",[s._v("这样看貌似没问题，但是我们会发现错误。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13cfdde82cd?w=611&h=282&f=png&s=42715",alt:"2019-07-05-19-17-05"}})]),s._v(" "),a("p",[s._v("我们看到 "),a("code",[s._v("action.payload")]),s._v(" 其实是两个函数返回类型的联合类型，但是我们在 "),a("code",[s._v("TOGGLE_TODO")]),s._v(" 的 "),a("code",[s._v("type")]),s._v(" 下就不应该出现 "),a("code",[s._v("todo: {...}")]),s._v(" 类型，为什么这里依然会出现呢？")]),s._v(" "),a("p",[s._v("其实正是因为我们错误运用了类型推导所致的，我们代码和逻辑都没有问题，问题就出现在我们没有理解好类型推导的机制。")]),s._v(" "),a("p",[s._v("类型推导生成的函数返回类型是这样的:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type AddTodoAction = {\n    payload: {\n        todo: {\n            done: boolean;\n            id: number;\n            name: string;\n        };\n    };\n    type: ActionTodoConstants;\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("而我们自定义的函数返回类型是这样的:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type AddTodoAction = {\n    type: ActionTodoConstants.ADD_TODO;\n    payload: {\n        todo: Todo;\n    };\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("其中最大的区别就是 "),a("code",[s._v("type")]),s._v(" 属性的类型，类型推导只推导到了一个枚举类型 "),a("code",[s._v("ActionTodoConstants")]),s._v(" ，而我们定义的类型是具体的 "),a("code",[s._v("ActionTodoConstants.ADD_TODO")]),s._v(" ,因此当我们在reducer中使用的时候，我们的自定义类型可以精准地推导出类型，而利用类型推导的方法却不行。")]),s._v(" "),a("p",[s._v("这里不得不提一个 typescript 下面的一个高级类型，可辨识联合类型（Discriminated Unions），这个高级类型我们之前已经提到过，我们再简单回顾下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('interface Square {\n    kind: "square";\n    size: number;\n}\ninterface Rectangle {\n    kind: "rectangle";\n    width: number;\n    height: number;\n}\n\ntype Shape = Square | Rectangle;\n\nfunction area(s: Shape) {\n    switch (s.kind) {\n        // 在此 case 中，变量 s 的类型为 Square\n        case "square": return s.size * s.size;\n        // 在此 case 中，变量 s 的类型为 Rectangle\n        case "rectangle": return s.height * s.width;\n    }\n}\n\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("p",[s._v("我们可以看到，这个联合类型可以通过 "),a("code",[s._v("case")]),s._v(" 识别不同的 "),a("code",[s._v("s.kind")]),s._v(" 从而推导出对应的类型，这个「可辨识联合」与普通的「联合类型」最大的不同之处就在于其必须有一个「单例类型」。")]),s._v(" "),a("p",[s._v("「单例类型」多数是指枚举成员类型和数字/字符串字面量类型，上面例子中的 "),a("code",[s._v("Rectangle")]),s._v(" 接口中的 "),a("code",[s._v('kind: "rectangle"')]),s._v(" 就是所谓的单例类型，你可能会好奇，这不是一个字符串吗？为什么是类型？其实在 TypeScript 中这种类型就叫做「字符串字面量类型」。")]),s._v(" "),a("p",[s._v("看个例子:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("type a = 'add'\n\nexport const b: a = 'add' // ok\nexport const c: a = 'delete' // 报错\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13cfdef2f6c?w=558&h=132&f=png&s=24602",alt:"2019-07-09-13-16-13"}})]),s._v(" "),a("p",[s._v("我们想推导出正确的类型靠的就是这个单一的「字符串字面量类型」，因此上面提到的利用函数返回值类型推导的方式就不符合这个要求，因此造成后面的推导错误是意料之中的事情了。")]),s._v(" "),a("p",[s._v("因此我们需要修改之前的 action 代码")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// actions/todo.ts\nexport interface AddTodoAction { type: ActionTodoConstants.ADD_TODO, payload: { todo: Todo } }\nexport interface ToggleTodoAction { type: ActionTodoConstants.TOGGLE_TODO, payload: { id: number } }\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("这个时候 reducer 中就可以精准推导:")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb13cfdf384d9?w=604&h=223&f=png&s=32215",alt:"2019-07-07-09-14-46"}})]),s._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("p",[s._v("我们在 Redux 相关的实战中运用了之前的各种类型，算是一个综合性质的实战，具体的代码可以阅读"),a("a",{attrs:{href:"https://github.com/xiaomuzhu/ts-start/tree/master/src/redux",target:"_blank",rel:"noopener noreferrer"}},[s._v("github上的示例代码"),a("OutboundLink")],1),s._v(".")]),s._v(" "),a("p",[s._v("到目前为止我们在使用层面上没有太大的问题了，但是依然有一些高级的类型我们还没有接触，而想在 TypeScript 进阶是离不开「类型编程」这道坎的，到底什么是类型编程，我们应该如何设计类型工具，那我们进入下一个阶段的学习吧。")])])}),[],!1,null,null,null);n.default=e.exports}}]);