(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{510:function(a,t,s){"use strict";s.r(t);var r=s(59),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"结论先说："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结论先说："}},[a._v("#")]),a._v(" 结论先说：")]),a._v(" "),s("ul",[s("li",[a._v("可执行jar，可以部署到服务器执行java -jar\n"),s("img",{attrs:{src:"/docs/images/2020-09-25-17-16-04.png",alt:""}})]),a._v(" "),s("li",[a._v("普通jar，不能java -jar执行，只能留给其他项目做依赖。\n"),s("img",{attrs:{src:"/docs/images/2020-09-25-17-16-51.png",alt:""}})])]),a._v(" "),s("h2",{attrs:{id:"可执行-jar-和普通-jar-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可执行-jar-和普通-jar-区别"}},[a._v("#")]),a._v(" 可执行 jar 和普通 jar 区别")]),a._v(" "),s("p",[a._v("在我们的项目中使用IDEA可以将项目打包，可以打成可执行jar和普通的jar包，那么这两种jar有什么区别呢？")]),a._v(" "),s("h3",{attrs:{id:"_1-打包插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-打包插件"}},[a._v("#")]),a._v(" 1.打包插件")]),a._v(" "),s("p",[a._v("Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 java -jar xxx.jar 命令执行，普通的 jar 主要是被其他应用依赖，Spring Boot 打成的 jar 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。")]),a._v(" "),s("p",[a._v("既然同样是执行 mvn package 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？原因就是两种jar目录结构不同。")]),a._v(" "),s("p",[a._v("这我们就不得不提 Spring Boot 项目中一个默认的插件配置 spring-boot-maven-plugin ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出："),s("br"),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190917233836933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pc3NPZlNwcmluZw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("build-info：生成项目的构建信息文件 build-info.properties")]),a._v(" "),s("li",[a._v("repackage：这个是默认 goal，在 mvn package 执行之后，这个命令再次打包生成可执行的 jar，同时将 mvn package 生成的 jar 重命名为 *.origin")]),a._v(" "),s("li",[a._v("run：这个可以用来运行 Spring Boot 应用")]),a._v(" "),s("li",[a._v("start：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理")]),a._v(" "),s("li",[a._v("stop：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理")])])]),a._v(" "),s("p",[a._v("这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。")]),a._v(" "),s("h3",{attrs:{id:"_2-打包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-打包"}},[a._v("#")]),a._v(" 2.打包")]),a._v(" "),s("p",[a._v("repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：")]),a._v(" "),s("p",[a._v("1.首先 mvn package 命令 对项目进行打包，打成一个 jar，这个 jar 就是一个普通的 jar，可以被其他项目依赖，但是不可以被执行。")]),a._v(" "),s("p",[a._v("2.repackage 命令，对第一步 打包成的 jar 进行再次打包，将之打成一个 可执行 jar ，通过将第一步打成的 jar 重命名为 *.original 文件。")]),a._v(" "),s("p",[a._v("对任意一个 Spring Boot 项目进行打包，可以执行 mvn package 命令，也可以直接在 IDEA 中点击 package ，如下 ："),s("br"),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190917232741226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pc3NPZlNwcmluZw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),s("br"),a._v("\n打包成功之后， target 中的文件如下："),s("br"),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019091723284031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pc3NPZlNwcmluZw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),s("br"),a._v("\n这里有两个文件，第一个 springapplication-0.0.1-SNAPSHOT.jar 表示打包成的可执行 jar ，第二个 springapplication-0.0.1-SNAPSHOT.jar.original 则是在打包过程中 ，被重命名的 jar，这是一个不可执行 jar，但是可以被其他项目依赖的 jar。")]),a._v(" "),s("p",[a._v("通过对这两个文件的解压，我们可以看出这两者之间的差异。")]),a._v(" "),s("h3",{attrs:{id:"_3-两种-jar-的比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-两种-jar-的比较"}},[a._v("#")]),a._v(" 3.两种 jar 的比较")]),a._v(" "),s("h4",{attrs:{id:"_3-1-可执行-jar-解压之后，目录如下："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-可执行-jar-解压之后，目录如下："}},[a._v("#")]),a._v(" 3.1 可执行 jar 解压之后，目录如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019091800130617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pc3NPZlNwcmluZw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),s("br"),a._v("\n可以看到，可执行 jar 中，我们自己的代码是存在 于 BOOT-INF/classes/ 目录下，另外，还有一个 META-INF 的目录，该目录下有一个 MANIFEST.MF 文件，打开该文件，内容如下：")]),a._v(" "),s("blockquote",[s("p",[a._v("Manifest-Version: 1.0"),s("br"),a._v("\nImplementation-Title: demo"),s("br"),a._v("\nImplementation-Version: 0.0.1-SNAPSHOT"),s("br"),a._v("\nStart-Class: com.allan.demo.DemoApplication"),s("br"),a._v("\nSpring-Boot-Classes: BOOT-INF/classes/"),s("br"),a._v("\nSpring-Boot-Lib: BOOT-INF/lib/"),s("br"),a._v("\nBuild-Jdk-Spec: 1.8"),s("br"),a._v("\nSpring-Boot-Version: 2.1.8.RELEASE"),s("br"),a._v("\nCreated-By: Maven Archiver 3.4.0"),s("br"),a._v("\nMain-Class: org.springframework.boot.loader.JarLauncher")])]),a._v(" "),s("p",[a._v("可以看到，这里定义了一个 Start-Class，这就是可执行 jar 的入口类，Spring-Boot-Classes 表示我们自己代码编译后的位置，Spring-Boot-Lib 则表示项目依赖的 jar 的位置。")]),a._v(" "),s("p",[a._v("换句话说，如果自己要打一个可执行 jar 包的话，除了添加相关依赖之外，还需要配置 META-INF/MANIFEST.MF 文件。")]),a._v(" "),s("h4",{attrs:{id:"_3-2-不可执行-jar-解压之后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-不可执行-jar-解压之后"}},[a._v("#")]),a._v(" 3.2 不可执行 jar 解压之后")]),a._v(" "),s("p",[a._v("首先将默认的后缀 .original 除去，进行解压，目录如下："),s("br"),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190918001800315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pc3NPZlNwcmluZw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}}),s("br"),a._v("\n解压后可以看到，不可执行 jar 根目录就相当于我们的 classpath，解压之后，直接就能看到我们的代码，它也有 META-INF/MANIFEST.MF 文件，但是文件中没有定义启动类等。打开该文件，内容如下：")]),a._v(" "),s("blockquote",[s("p",[a._v("Manifest-Version: 1.0"),s("br"),a._v("\nImplementation-Title: demo"),s("br"),a._v("\nImplementation-Version: 0.0.1-SNAPSHOT"),s("br"),a._v("\nBuild-Jdk-Spec: 1.8"),s("br"),a._v("\nCreated-By: Maven Archiver 3.4.0")])]),a._v(" "),s("p",[a._v("注意:这个不可以执行 jar 也没有将项目的依赖打包进来。")]),a._v(" "),s("p",[a._v("从这里我们就可以看出，两个 jar ，虽然都是 jar 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。")]),a._v(" "),s("h3",{attrs:{id:"_4-一次打包两个-jar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-一次打包两个-jar"}},[a._v("#")]),a._v(" 4.一次打包两个 jar")]),a._v(" "),s("p",[a._v("一般来说，Spring Boot 直接打包成可执行 jar 就可以了，不建议将 Spring Boot 作为普通的 jar 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 Maven 项目，然后在 Spring Boot 中引用这个 Maven 项目。")]),a._v(" "),s("p",[a._v("如果非要将 Spring Boot 打包成一个普通 jar 被其他项目依赖，技术上来说，也是可以的，给 spring-boot-maven-plugin 插件添加如下配置：")]),a._v(" "),s("div",{staticClass:"language-xml line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-xml"}},[s("code",[a._v("\t"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("build")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("plugins")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("plugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("org.springframework.boot"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("groupId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("spring-boot-maven-plugin"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("artifactId")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("configuration")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("classifier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("exec"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("classifier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("configuration")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("plugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("plugins")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("build")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])]),s("p",[a._v("配置的 classifier 表示可执行 jar 的名字，配置了这个之后，在插件执行 repackage 命令时，就不会给 mvn package 所打成的 jar 重命名了，所以，打包后的 jar 如下："),s("br"),a._v(" "),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190917235304760.png",alt:"在这里插入图片描述"}}),s("br"),a._v("\n第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。")])])}),[],!1,null,null,null);t.default=n.exports}}]);