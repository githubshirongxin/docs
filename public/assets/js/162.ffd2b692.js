(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{645:function(e,a,s){"use strict";s.r(a);var n=s(59),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"高级类型之条件类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高级类型之条件类型"}},[e._v("#")]),e._v(" 高级类型之条件类型")]),e._v(" "),s("p",[e._v("之所以叫类型编程,是因为我们可以对_类型_进行编程了,比如之前我们的类型基本都是写死的,比如这样:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type F = string\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("但是有时候我们并不能再编写代码的时候就把类型确定了,到底是什么类型还是需要一些外部条件的,那么这个时候应该怎么办?")]),e._v(" "),s("p",[e._v("TypeScript 在2.8版本之后引入了条件类型(conditional type).")]),e._v(" "),s("h2",{attrs:{id:"条件类型的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条件类型的使用"}},[e._v("#")]),e._v(" 条件类型的使用")]),e._v(" "),s("p",[e._v("条件类型够表示非统一的类型,以一个条件表达式进行类型关系检测，从而在两种类型中选择其一:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("T extends U ? X : Y\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("上面的代码可以理解为: 若 "),s("code",[e._v("T")]),e._v(" 能够赋值给 "),s("code",[e._v("U")]),e._v("，那么类型是 "),s("code",[e._v("X")]),e._v("，否则为 "),s("code",[e._v("Y")]),e._v(",有点类似于JavaScript中的三元条件运算符.")]),e._v(" "),s("p",[e._v("比如我们声明一个函数 "),s("code",[e._v("f")]),e._v(",它的参数接收一个布尔类型,当布尔类型为 "),s("code",[e._v("true")]),e._v(" 时返回 "),s("code",[e._v("string")]),e._v(" 类型,否则返回 "),s("code",[e._v("number")]),e._v(" 类型:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("declare function f<T extends boolean>(x: T): T extends true ? string : number;\n\nconst x = f(Math.random() < 0.5)\nconst y = f(false)\nconst z = f(true)\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("而 "),s("code",[e._v("x,y,z")]),e._v(" 的类型分别如下:")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb142562f98dd?w=355&h=61&f=png&s=11489",alt:"2019-09-25-23-14-23"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb14257578f5b?w=295&h=68&f=png&s=8648",alt:"2019-09-25-23-14-37"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb142576db052?w=300&h=76&f=png&s=8381",alt:"2019-09-25-23-14-51"}})]),e._v(" "),s("p",[e._v("条件类型就是这样,只有类型系统中给出充足的条件之后,它才会根据条件推断出类型结果.")]),e._v(" "),s("h2",{attrs:{id:"条件类型与联合类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条件类型与联合类型"}},[e._v("#")]),e._v(" 条件类型与联合类型")]),e._v(" "),s("p",[e._v("条件类型有一个特性,就是「分布式有条件类型」,但是分布式有条件类型是有前提的,条件类型里待检查的类型必须是"),s("code",[e._v("naked type parameter")]),e._v(".")]),e._v(" "),s("p",[e._v("好了,肯定有人已经晕了,什么是分布式有条件类型?"),s("code",[e._v("naked type parameter")]),e._v("又是什么?")]),e._v(" "),s("p",[s("code",[e._v("naked type parameter")]),e._v("指的是"),s("strong",[e._v("裸类型参数")]),e._v(",怎么理解?这个「裸」是指类型参数没有被包装在其他类型里,比如没有被数组、元组、函数、Promise等等包裹.")]),e._v(" "),s("p",[e._v("我们举个简单的例子:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// 裸类型参数,没有被任何其他类型包裹即T\ntype NakedUsage<T> = T extends boolean ? "YES" : "NO"\n// 类型参数被包裹的在元组内即[T]\ntype WrappedUsage<T> = [T] extends [boolean] ? "YES" : "NO";\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("好了,"),s("code",[e._v("naked type parameter")]),e._v("我们了解了之后,「分布式有条件类型」就相对容易理解了,按照官方文档的说法是「分布式有条件类型在实例化时会自动分发成联合类型」.")]),e._v(" "),s("p",[e._v("这个说法很绕,我们直接看例子:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('type Distributed = NakedUsage<number | boolean> //  = NakedUsage<number> | NakedUsage<boolean> =  "NO" | "YES"\ntype NotDistributed = WrappedUsage<number | boolean > // "NO"\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("当我们给类型"),s("code",[e._v("NakedUsage")]),e._v("加入联合类型"),s("code",[e._v("number | boolean")]),e._v("时,它的结果返回"),s("code",[e._v('"NO" | "YES"')]),e._v(",相当于联合类型中的"),s("code",[e._v("number")]),e._v("和"),s("code",[e._v("boolean")]),e._v("分别赋予了"),s("code",[e._v("NakedUsage<T>")]),e._v("然后再返回出一个联合类型,这个操作大家可以类比JavaScript中的"),s("code",[e._v("Array.map()")])]),e._v(" "),s("blockquote",[s("p",[e._v("JavaScript中map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。")])]),e._v(" "),s("p",[e._v("我们看"),s("code",[e._v("NotDistributed")]),e._v("的结果,他接受的同样是联合类型"),s("code",[e._v("number | boolean")]),e._v(",但是返回一个特定的类型"),s("code",[e._v('"NO"')]),e._v(",而非一个联合类型,就是因为他的类型参数是被包裹的即"),s("code",[e._v("[<T>]")]),e._v(",不会产生分布式有条件类型的特性.")]),e._v(" "),s("p",[e._v("这一部分比较难以理解,我们可以把「分布式有条件类型」粗略得理解为类型版的"),s("code",[e._v("map()方法")]),e._v(",然后我们再看一些实用案例加深理解.")]),e._v(" "),s("p",[e._v("我们先思考一下,如何设计一个类型工具"),s("code",[e._v("Diff<T, U>")]),e._v(",我们要找出"),s("code",[e._v("T")]),e._v("类型中"),s("code",[e._v("U")]),e._v("不包含的部分:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('type R = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("联合类型"),s("code",[e._v('"a" | "b" | "c" | "d"')]),e._v("与"),s("code",[e._v('"a" | "c" | "f"')]),e._v("相比,后者不包含"),s("code",[e._v('"b" | "d"')]),e._v(".")]),e._v(" "),s("p",[e._v("我们借助有条件类型很容易写出这个工具函数:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type Diff<T, U> = T extends U ? never : T;\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("同样的,我们可以生产出"),s("code",[e._v("Filter<T, U>")]),e._v(" "),s("code",[e._v("NonNullable<T>")]),e._v("等工具类型:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 类似于js数组的filter\ntype Filter<T, U> = T extends U ? T : never;\ntype R1 = Filter<string | number | (() => void), Function>;\n\n// 剔除 null和undefined\ntype NonNullable<T> = Diff<T, null | undefined>;\n\ntype R2 = NonNullable<string | number | undefined>;  // string | number\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("我们会在后面专门的章节介绍如何构建这些工具类型,而工具类型的编写离不开「分布式有条件类型」的帮助.")]),e._v(" "),s("h2",{attrs:{id:"条件类型与映射类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条件类型与映射类型"}},[e._v("#")]),e._v(" 条件类型与映射类型")]),e._v(" "),s("p",[e._v("这一小部分需要读者对映射类型有基本的了解,我们依然是先看一个思考题:")]),e._v(" "),s("p",[e._v("我没有一个interface "),s("code",[e._v("Part")]),e._v(",现在需要编写一个工具类型将interface中"),s("strong",[e._v("函数类型")]),e._v("的"),s("strong",[e._v("名称")]),e._v("取出来,在这个题目示例中,应该取出的是:")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/11/16dbb1425771bb18?w=416&h=106&f=png&s=13355",alt:"2019-09-26-12-03-00"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("interface Part {\n    id: number;\n    name: string;\n    subparts: Part[];\n    updatePart(newName: string): void;\n}\n\ntype R = FunctionPropertyNames<Part>;\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("那么你会如何设计这个工具类型?")]),e._v(" "),s("blockquote",[s("p",[e._v("在一些有要求TS基础的公司,设计工具类型是一个比较大的考点.")])]),e._v(" "),s("p",[e._v("这种问题我们应该换个思路,比如我们把interface看成js中的对象字面量,用js的思维你会如何取出?")]),e._v(" "),s("p",[e._v("这个时候问题就简单了,遍历整个对象,找出value是函数的部分取出key即可.")]),e._v(" "),s("p",[e._v("在TypeScript的类型编程中也是类似的道理,我们要遍历interface,取出类型为"),s("code",[e._v("Function")]),e._v("的部分找出key即可:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("我一步步分析一下上述工具类型(我们按照js的思维讲解,可能有不严谨之处,但是有助于你的理解):")]),e._v(" "),s("ol",[s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("假设我们把`Part`代入泛型`T`,`[K in keyof T]`相当于遍历整个interface\n")])])])]),e._v(" "),s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("这时`K`相当于interface的key,`T[K]`相当于interface的value\n")])])])]),e._v(" "),s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("接下来,用条件类型验证value的类型,如果是`Function`那么将value作为新interface的key保留下来,否则为`never`\n")])])])]),e._v(" "),s("li",[s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("到这里我们得到了遍历修改后的**新**interface即:\n")])])])])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('type R = {\n    id: never;\n    name: never;\n    subparts: never;\n    updatePart: "updatePart";\n}\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("blockquote",[s("p",[e._v("特别注意: 这里产生的新interface R中的value是老interface Part的key,取出新interface R的value就是取出了对应老interface Part的key")])]),e._v(" "),s("ol",[s("li",[e._v("但是我们的的要求是取出老interface Part的key,这个时候再次用"),s("code",[e._v("[keyof T]")]),e._v("作为key依次取出新interface的value,但是由于"),s("code",[e._v("id")]),e._v(" "),s("code",[e._v("name")]),e._v("和"),s("code",[e._v("subparts")]),e._v("的value为"),s("code",[e._v("never")]),e._v("就不会返回任何类型了,所以只返回了"),s("code",[e._v("'updatePart'")]),e._v(".")])]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("never")]),e._v("类型表示不会是任何值,即什么都没有,甚至不是"),s("code",[e._v("null")]),e._v("类型")])]),e._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("这一节的信息量很大,如果没有仔细搞清楚之前的映射类型相关的知识,理解起来会比较困难,不过没关系,我们后面会有一个专门的章节讲工具类型的设计,还会涉及相关的内容,不过今天有一个思考题:")]),e._v(" "),s("p",[e._v("如何取出下面interface中的可选类型?")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("interface People = {\n  id: string\n  name: string\n  age?: number\n  from?: string\n}\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("即")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('type R = NullableKeys<People> // type R = "age" | "from"\n\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("blockquote",[s("p",[e._v("提示: TypeScript中有一类符号,"),s("code",[e._v("+")]),e._v("或"),s("code",[e._v("-")]),e._v("允许控制映射的类型修饰符（例如?或readonly),"),s("code",[e._v("-?")]),e._v("意味着必须全部存在,意味着将消除类型映射的可选类型.")])])])}),[],!1,null,null,null);a.default=t.exports}}]);