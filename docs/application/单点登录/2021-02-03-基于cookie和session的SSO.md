---
layout: post
title: 基于cookie和session的SSO
---

## 来源bilibili：跨域单点登录分析及项目实战
[来源bilibili：跨域单点登录分析及项目实战](https://www.bilibili.com/video/BV1p4411d7xU?from=search&seid=16384800873662952735)

![](/docs/images/2021-02-03-08-12-15.png)
![](/docs/images/2021-02-03-08-13-01.png)

需求
![](/docs/images/2021-02-03-08-18-24.png)


##  知乎图解JWT如何用于单点登录
[参考：知乎图解JWT如何用于单点登录](https://zhuanlan.zhihu.com/p/70371906)
场景一：用户发起对业务系统的第一次访问，假设他第一次访问的是系统A的some/page这个页面，它最终成功访问到这个页面的过程是：
![](/docs/images/2021-02-03-08-26-57.png)
场景二：用户登录之后，继续访问系统A的其它页面，如some/page2，它的处理过程是：
![](/docs/images/2021-02-03-08-27-07.png)

场景三：用户登录了系统A之后，再去访问其他系统如系统B的资源，比如系统B的some/page，它最终能访问到系统B的some/page的流程是：
![](/docs/images/2021-02-03-08-27-37.png)

场景四：用户继续访问系统B的其它资源，如系统B的some/page2：
![](/docs/images/2021-02-03-08-27-51.png)

场景五：退出登录，假如它从系统B发起退出，最终的流程是：
![](/docs/images/2021-02-03-08-28-03.png)

## 方案总结
### 以上方案两个关键的前提：

* 整个会话管理其实还是基于服务端的session来做的，只不过这个session只存在于CAS服务里面；
* CAS之所以信任业务系统的jwt，是因为这个jwt是CAS签发的，理论上只要认证通过，就可以认为这个jwt是合法的。
* jwt本身是不可伪造，不可篡改的，但是不代表非法用户冒充正常用法发起请求，所以常规的几个安全策略在实际项目中都应该使用：

* 使用https
* 使用http-only的cookie，针对sid和jwt
* 管理好密钥
* 防范CSRF攻击。
尤其是CSRF攻击形式，很多都是钻代码的漏洞发生的，所以一旦出现CSRF漏洞，并且被人利用，那么别人就能用获得的jwt，冒充正常用户访问所有业务系统，这个安全问题的后果还是很严重的。考虑到这一点，为了在即使有漏洞的情况将损害减至最小，可以在jwt里面加入一个系统标识，添加一个验证，只有传过来的jwt内的系统标识与发起jwt验证请求的服务一致的情况下，才允许验证通过。这样的话，一个非法用户拿到某个系统的jwt，就不能用来访问其它业务系统了。

在业务系统跟CAS发起attach/validate请求的时候，也可以在CAS端做些处理，因为这个请求，在一次SSO过程中，一个系统只应该发一次，所以只要之前已经给这个系统签发过jwt了，那么后续 同一系统的attach/validate请求都可以忽略掉。

总的来说，
### 这个方案的好处有：

* 完全分布式，跨平台，CAS以及业务系统均可采用不同的语言来开发；
* 业务系统如系统A和系统B，可实现服务端无状态
* 假如是自己来实现，那么可以轻易的在CAS里面集成用户注册服务以及第三方登录服务，如微信登录等。
### 它的缺陷是：

* 第一次登录某个系统，需要三次重定向（不过可以优化成两次）；
* 登录后的后续请求，每次都需要跟CAS进行会话验证，所以CAS的性能负载会比较大
* 登陆后的后续请求，每次都跟CAS交互，也会增加请求响应时间，影响用户体验。
