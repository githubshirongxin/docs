---
laytout: post
title: 【gitla-ci】发布实践
---

## 1 使用GitlabRunner充当发布用的服务器。比较容易，但是丑陋。
::: warning
 Runner和部署服务器是一台。整体思路就不推荐这么做。
:::
- https://blog.csdn.net/qq_27520051/article/details/80552220
  - 代码从gitlab pull下来就完成了发布。

- https://www.jianshu.com/p/b1e098cdb46b
  - 在gitlab-runner上git pull代码，并编译。


- https://blog.csdn.net/junmoxi/article/details/82762413
  - gitlab-ci.yml全是echo，没有一句真的。但是告诉你思路应该是Runner上执行shell。
  - 就这还需要把Runner服务器上生成公钥，放到gitlab上。就是为了git pull到runner上。

- https://www.cnblogs.com/hongsusu/p/10142428.html
  - gitlabrunner上git pull代码（为了能pull还得把gitlabrunner的key放到gitlab的某个用户的SSH key里。）
  - 【疑问】git pull了代码就完成部署了吗？


- https://segmentfault.com/a/1190000015692830
  - 就是npm publish然后把用户名，密码都写道脚本里，发布到npm仓库（私有或公有），就发布完了。
  - 这明显只适合npm包的开发工作。

### 1.2 gitlab-ci Docker化部署
#### 1.2.1  使用docker镜像库。build就是上传镜像，deploy就是拉取镜像并生成容器
- https://www.jianshu.com/p/dc603463ef55
  - build就是在RUnner上编译，并上传docker镜像库
  - deploy就是在Runner上拉取镜像并生成了容器，使用docker-compose或不使用（直接docker run）
#### 1.2.2 没使用docker镜像仓库。build就是打包成镜像。deploy就是在runner上生成镜像。
- https://www.jianshu.com/p/c398509f8861
  - 根本不用docker镜像仓库。就是在runner上直接打包成镜像。然后删除正在运行的容器。docker run生成容器。
- https://www.cnblogs.com/luffyxin/p/12800889.html
  - 同上。Runner上build阶段build镜像，deploy生成容器。
  - 不是很好的方案
::: warning
 Runner和部署服务器是一台。整体思路就不推荐这么做。
:::
---
## 2 部署服务器和Runner是不同的机器。这是比较正常

### 2.1 非docker化部署
- https://segmentfault.com/a/1190000020622168
  - 这是一篇比较完整的gitlab-ci发布到服务器的配置。runner上编译。编译后的东西拷贝到服务器。服务器不是Runner
  - 把Runner上生成的公钥拷贝到另一台服务器的~/.ssh/authorized_keys文件中。
  - 【常识】gitlab-ci的头部，可以写一些设置npm代理仓库。不知道能不能登陆仓库。
  - ssh到另一台服务器，采用了不验证服务器公钥的方式。见下面链接。
  - https://blog.csdn.net/aabbcc456aa/article/details/18981279
    - 【不用公钥验证的自动】不检查远端主机的公钥。

### 2.2 docker化部署，三个分支分别部署到三个不同的服务器。相当靠谱。
- https://blog.csdn.net/fly910905/article/details/106425489/
   - 这里面的maven:3.6.3-jdk-11-slim既有maven又有java。
   - 这篇文章值得参考。
- https://www.kubernetes.org.cn/7522.html（和上面是一篇文章。）
   - 相当成熟的方案。runner和部署服务器分开。并且三个分支部署到三个不同的服务器。相当靠谱。
   - 同样。build就是编译工程。
   - build imag就是制作镜像并上传docker私有仓库。 
   - deploy就是到对应的服务器上下载镜像。并停止掉旧的容器，生成新的容器。
   ::: tip 
   这是相当靠谱的方案！思路就应该是这个思路。
   :::
---
## 3. 服务器与RUnner是否是一台。不明！！
- https://segmentfault.com/a/1190000021092024?utm_source=tag-newest
  - 就是npm run deploy , 这就算发布了？疑问！


## webhook 是啥？
https://www.cnblogs.com/zhihuifan10/p/11114816.html





